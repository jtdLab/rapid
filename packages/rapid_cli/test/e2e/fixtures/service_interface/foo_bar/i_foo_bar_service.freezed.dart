// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'i_foo_bar_service.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FooBarServiceMethod1Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method1FailureA value) failureA,
    required TResult Function(_Method1FailureB value) failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method1FailureA value)? failureA,
    TResult? Function(_Method1FailureB value)? failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method1FailureA value)? failureA,
    TResult Function(_Method1FailureB value)? failureB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FooBarServiceMethod1FailureCopyWith<$Res> {
  factory $FooBarServiceMethod1FailureCopyWith(
          FooBarServiceMethod1Failure value,
          $Res Function(FooBarServiceMethod1Failure) then) =
      _$FooBarServiceMethod1FailureCopyWithImpl<$Res,
          FooBarServiceMethod1Failure>;
}

/// @nodoc
class _$FooBarServiceMethod1FailureCopyWithImpl<$Res,
        $Val extends FooBarServiceMethod1Failure>
    implements $FooBarServiceMethod1FailureCopyWith<$Res> {
  _$FooBarServiceMethod1FailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_Method1FailureACopyWith<$Res> {
  factory _$$_Method1FailureACopyWith(
          _$_Method1FailureA value, $Res Function(_$_Method1FailureA) then) =
      __$$_Method1FailureACopyWithImpl<$Res>;
}

/// @nodoc
class __$$_Method1FailureACopyWithImpl<$Res>
    extends _$FooBarServiceMethod1FailureCopyWithImpl<$Res, _$_Method1FailureA>
    implements _$$_Method1FailureACopyWith<$Res> {
  __$$_Method1FailureACopyWithImpl(
      _$_Method1FailureA _value, $Res Function(_$_Method1FailureA) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Method1FailureA implements _Method1FailureA {
  const _$_Method1FailureA();

  @override
  String toString() {
    return 'FooBarServiceMethod1Failure.failureA()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Method1FailureA);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) {
    return failureA();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) {
    return failureA?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) {
    if (failureA != null) {
      return failureA();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method1FailureA value) failureA,
    required TResult Function(_Method1FailureB value) failureB,
  }) {
    return failureA(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method1FailureA value)? failureA,
    TResult? Function(_Method1FailureB value)? failureB,
  }) {
    return failureA?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method1FailureA value)? failureA,
    TResult Function(_Method1FailureB value)? failureB,
    required TResult orElse(),
  }) {
    if (failureA != null) {
      return failureA(this);
    }
    return orElse();
  }
}

abstract class _Method1FailureA implements FooBarServiceMethod1Failure {
  const factory _Method1FailureA() = _$_Method1FailureA;
}

/// @nodoc
abstract class _$$_Method1FailureBCopyWith<$Res> {
  factory _$$_Method1FailureBCopyWith(
          _$_Method1FailureB value, $Res Function(_$_Method1FailureB) then) =
      __$$_Method1FailureBCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_Method1FailureBCopyWithImpl<$Res>
    extends _$FooBarServiceMethod1FailureCopyWithImpl<$Res, _$_Method1FailureB>
    implements _$$_Method1FailureBCopyWith<$Res> {
  __$$_Method1FailureBCopyWithImpl(
      _$_Method1FailureB _value, $Res Function(_$_Method1FailureB) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Method1FailureB implements _Method1FailureB {
  const _$_Method1FailureB();

  @override
  String toString() {
    return 'FooBarServiceMethod1Failure.failureB()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Method1FailureB);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) {
    return failureB();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) {
    return failureB?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) {
    if (failureB != null) {
      return failureB();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method1FailureA value) failureA,
    required TResult Function(_Method1FailureB value) failureB,
  }) {
    return failureB(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method1FailureA value)? failureA,
    TResult? Function(_Method1FailureB value)? failureB,
  }) {
    return failureB?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method1FailureA value)? failureA,
    TResult Function(_Method1FailureB value)? failureB,
    required TResult orElse(),
  }) {
    if (failureB != null) {
      return failureB(this);
    }
    return orElse();
  }
}

abstract class _Method1FailureB implements FooBarServiceMethod1Failure {
  const factory _Method1FailureB() = _$_Method1FailureB;
}

/// @nodoc
mixin _$FooBarServiceMethod2Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method2FailureA value) failureA,
    required TResult Function(_Method2FailureB value) failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method2FailureA value)? failureA,
    TResult? Function(_Method2FailureB value)? failureB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method2FailureA value)? failureA,
    TResult Function(_Method2FailureB value)? failureB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FooBarServiceMethod2FailureCopyWith<$Res> {
  factory $FooBarServiceMethod2FailureCopyWith(
          FooBarServiceMethod2Failure value,
          $Res Function(FooBarServiceMethod2Failure) then) =
      _$FooBarServiceMethod2FailureCopyWithImpl<$Res,
          FooBarServiceMethod2Failure>;
}

/// @nodoc
class _$FooBarServiceMethod2FailureCopyWithImpl<$Res,
        $Val extends FooBarServiceMethod2Failure>
    implements $FooBarServiceMethod2FailureCopyWith<$Res> {
  _$FooBarServiceMethod2FailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_Method2FailureACopyWith<$Res> {
  factory _$$_Method2FailureACopyWith(
          _$_Method2FailureA value, $Res Function(_$_Method2FailureA) then) =
      __$$_Method2FailureACopyWithImpl<$Res>;
}

/// @nodoc
class __$$_Method2FailureACopyWithImpl<$Res>
    extends _$FooBarServiceMethod2FailureCopyWithImpl<$Res, _$_Method2FailureA>
    implements _$$_Method2FailureACopyWith<$Res> {
  __$$_Method2FailureACopyWithImpl(
      _$_Method2FailureA _value, $Res Function(_$_Method2FailureA) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Method2FailureA implements _Method2FailureA {
  const _$_Method2FailureA();

  @override
  String toString() {
    return 'FooBarServiceMethod2Failure.failureA()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Method2FailureA);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) {
    return failureA();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) {
    return failureA?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) {
    if (failureA != null) {
      return failureA();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method2FailureA value) failureA,
    required TResult Function(_Method2FailureB value) failureB,
  }) {
    return failureA(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method2FailureA value)? failureA,
    TResult? Function(_Method2FailureB value)? failureB,
  }) {
    return failureA?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method2FailureA value)? failureA,
    TResult Function(_Method2FailureB value)? failureB,
    required TResult orElse(),
  }) {
    if (failureA != null) {
      return failureA(this);
    }
    return orElse();
  }
}

abstract class _Method2FailureA implements FooBarServiceMethod2Failure {
  const factory _Method2FailureA() = _$_Method2FailureA;
}

/// @nodoc
abstract class _$$_Method2FailureBCopyWith<$Res> {
  factory _$$_Method2FailureBCopyWith(
          _$_Method2FailureB value, $Res Function(_$_Method2FailureB) then) =
      __$$_Method2FailureBCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_Method2FailureBCopyWithImpl<$Res>
    extends _$FooBarServiceMethod2FailureCopyWithImpl<$Res, _$_Method2FailureB>
    implements _$$_Method2FailureBCopyWith<$Res> {
  __$$_Method2FailureBCopyWithImpl(
      _$_Method2FailureB _value, $Res Function(_$_Method2FailureB) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Method2FailureB implements _Method2FailureB {
  const _$_Method2FailureB();

  @override
  String toString() {
    return 'FooBarServiceMethod2Failure.failureB()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Method2FailureB);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() failureA,
    required TResult Function() failureB,
  }) {
    return failureB();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? failureA,
    TResult? Function()? failureB,
  }) {
    return failureB?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? failureA,
    TResult Function()? failureB,
    required TResult orElse(),
  }) {
    if (failureB != null) {
      return failureB();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Method2FailureA value) failureA,
    required TResult Function(_Method2FailureB value) failureB,
  }) {
    return failureB(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Method2FailureA value)? failureA,
    TResult? Function(_Method2FailureB value)? failureB,
  }) {
    return failureB?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Method2FailureA value)? failureA,
    TResult Function(_Method2FailureB value)? failureB,
    required TResult orElse(),
  }) {
    if (failureB != null) {
      return failureB(this);
    }
    return orElse();
  }
}

abstract class _Method2FailureB implements FooBarServiceMethod2Failure {
  const factory _Method2FailureB() = _$_Method2FailureB;
}
