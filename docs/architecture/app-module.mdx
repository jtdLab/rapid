export const BoldText = (props) => {
  return (
    <span style={{ fontWeight: "bold" }}>
      {props.children}
    </span>
  );
};

export const Chip = (props) => {
  const chipStyle = {
    display: 'inline-flex', 
    alignItems: 'center',
    backgroundColor: props.color,
    color: 'white',
    fontWeight: 'bold',
    borderRadius: '16px',
    padding: '4px 8px',
    margin: '4px',
    cursor: props.link ? 'pointer' : 'default',
    textDecoration: 'none',
    fontSize: '12px',
    boxSizing: 'border-box'
  };

  return (
    props.link ? (
      <a href={props.link} style={chipStyle} target="_blank" rel="noopener noreferrer">
        {props.children}
      </a>
    ) : (
      <span style={chipStyle}>
        {props.children}
      </span>
    )
  );
};


# App Module

<Image
  src="assets/app_module_overview.svg"
  alt="App Module Overview"
  zoom={true}
  height="250"
/>

## Dependency Injection Package

<div>
  <Chip color="#28A745">get_it</Chip>
  <Chip color="#007BFF" link="https://pub.dev/packages/injectable">
    injectable
  </Chip>
</div>

<BoldText>ðŸŽ¯ Provide a dependency injection container.</BoldText>

<BoldText>ðŸŽ¯ Provide platform annotations for dependency injection.</BoldText>

This package uses [get_it](https://pub.dev/packages/get_it) to offer the applications central dependency injection container. Other packages will retrieve dependencies from it and use [injectable](https://pub.dev/packages/injectable) to register them beforehand.
In addition to providing the dependency container, this package introduces annotations that enable the registration of specific dependencies for particular platforms.

## Logging Package

<BoldText>ðŸŽ¯ Provide a logger.</BoldText>

The primary goal of this package is to offer a single, dedicated logger that can be effortlessly employed throughout the entire application. By default, an implementation is provided, yet developers have the freedom to either create their own customized logger or use existing solutions like for example [logger](https://pub.dev/packages/logger) or [logging](https://pub.dev/packages/logging).

## Platform Root Package

<BoldText>ðŸŽ¯ Provide entrypoints to run the application in different environments.</BoldText>

<BoldText>ðŸŽ¯ Setup Dependency Injection.</BoldText>

<BoldText>ðŸŽ¯ Setup Routing.</BoldText>

<BoldText>ðŸŽ¯ Provide a BlocObserver.</BoldText>

<BoldText>ðŸŽ¯ Provide a RouterObserver.</BoldText>

<BoldText>ðŸŽ¯ Integration Testing.</BoldText>

This package provides entry points for different environments via `main_development.dart`, `main_test.dart`, and `main_prod.dart`, where the application gets set up depending on the needs of each environment. It initializes dependency injection, routing, logging and hosts the native application. The package is also the location where integration tests take place.

More information about testing a [Platform Root Package](/architecture/app-module#platform-root-package) can be found [here](/architecture/testing#testing-platform-root-package).

## Platform Navigation Package

<BoldText>ðŸŽ¯ Provide interfaces to navigate between feature packages.</BoldText>

The primary goal of this package is to decouple [Platform Feature Packages](/architecture/app-module#platform-feature-package) and allow navigation between them. This is achieved by defining [Navigator Interfaces](/architecture/app-module#navigator-interface) for each feature package that will be navigated to from within another feature package. The interface will then be implemented in the associated feature package using a [Navigator Implementation](/architecture/app-module#navigator-implementation) which is registred to the dependency injection container.
Feature packages that want to navigate to the feature package can then use the injected implementation instead of depending on the feature package directly.

### Navigator Interface

```dart
// i_home_page_navigator.dart
abstract class IHomePageNavigator {
  // TODO: add navigation methods here
}
```

## Platform Localization Package

<BoldText>ðŸŽ¯ Provide translations for different languages.</BoldText>

The main purpose of this package is to provide localization for the application. This is done using `.arb` files via [flutter_localizations](https://docs.flutter.dev/ui/accessibility-and-localization/internationalization) and [intl](https://pub.dev/packages/intl).

## Platform Feature Package

<BoldText>ðŸŽ¯ Implement states and user interface of a feature.</BoldText>

### Bloc

```dart
// counter_bloc.dart
@android
@injectable
class CounterBloc extends Bloc<CounterEvent, int> {
  CounterBloc()
      : super(
          // Set initial state
          0,
        ) {
    // Register handlers
    on<CounterStarted>(_onIncrement);
  }

  /// Handle incoming [CounterIncrement] event.
  void _onIncrement(
    CounterIncrement event,
    Emitter<int> emit,
  ) {
    emit(state + 1);
  }
}

// counter_event.dart
@freezed
sealed class CounterEvent with _$CounterEvent {
  const factory CounterEvent.increment() = CounterIncrement;
}

// counter_state.dart
// (not needed in this example)
```

### Cubit

```dart
// counter_cubit.dart
@android
@injectable
class CounterCubit extends Cubit<int> {
  CounterCubit()
      : super(
          // Set initial state
          0,
        );

  void started() {
    emit(state + 1);
  }
}

// counter_state.dart
// (not needed in this example)
```

### Navigator Implementation

```dart
// navigator.dart
@android
@LazySingleton(as: IHomePageNavigator)
class HomePageNavigator implements IHomePageNavigator {
  // TODO: implement
}
```

More information about testing a [Platform Feature Package](/architecture/app-module#platform-feature-package) can be found [here](/architecture/testing#testing-platform-feature-package).

## Domain Package

<BoldText>ðŸŽ¯ Represent a domain using [Entities](/architecture/app-module#entity), [Service Interfaces](/architecture/app-module#service-interface) and [Value Objects](/architecture/app-module#value-object).</BoldText>

A domain package models a specific domain using domain components. It serves as the boundary to the external world and is implemented by its associated [Infrastructure Package](/architecture/app-module#infrastructure-package). Objects exposed by this package are immutable, and exceptions are represented by seperate failure classes (see [Value Object](/architecture/app-module#value-object), [Service Interface](/architecture/app-module#service-interface)) to achieve domain safety.

<Info>
  Domain Safety refers to the domain being designed in an expressive way,
  mitigating possible errors introduced by mutable models and uncaught
  exceptions.
</Info>

### Entity

```dart
// user.dart
@freezed
class User with _$User {
  const factory User({
    required String id,
    // TODO: add more fields here
  }) = _User;

  factory User.random() {
    final faker = Faker();

    return User(
      id: faker.randomGenerator.string(16, min: 16),
    );
  }
}
```

### Service Interface

```dart
// i_authentication_service.dart
abstract class IAuthenticationService {
  MyMethodResult myMethod();

  // TODO: add more service methods
}

sealed class MyMethodResult {
  const MyMethodResult();
}

@freezed
class MyMethodSuccess extends MyMethodResult with _$MyMethodSuccess {
  const factory MyMethodSuccess(String value) = _MyMethodSuccess;
  const MyMethodSuccess._();
}

@freezed
sealed class MyMethodFailure extends MyMethodResult with _$MyMethodFailure {
  const MyMethodFailure._();
  const factory MyMethodFailure.foo() = MyMethodFailureFoo;
  // TODO: add more failure cases here
}

// TODO: add more service method results here
```

### Value Object

```dart
// email_address.dart
sealed class EmailAddress {
  factory EmailAddress(String raw) {
    return _validate(raw);
  }

  factory EmailAddress.random({bool valid = true}) {
    final faker = Faker();

    if (valid) {
      return faker.randomGenerator.element([
        // TODO: insert random valid instances here
      ]);
    } else {
      return faker.randomGenerator.element([
        // TODO: insert random invalid instances here
      ]);
    }
  }

  const EmailAddress._();

  static EmailAddress _validate(String raw) {
    // TODO: implement validation here
    throw UnimplementedError();
  }

  String getOrCrash() {
    return switch (this) {
      final ValidEmailAddress valid => valid.value,
      final EmailAddressFailure failure =>
        throw StateError('Unexpected $failure at unrecoverable point.'),
    };
  }

  bool isValid() => this is ValidEmailAddress;
}

@freezed
class ValidEmailAddress extends EmailAddress with _$ValidEmailAddress {
  const factory ValidEmailAddress(String value) = _ValidEmailAddress;
  const ValidEmailAddress._() : super._();
}

@freezed
sealed class EmailAddressFailure extends EmailAddress
    with _$EmailAddressFailure {
  const EmailAddressFailure._() : super._();
  const factory EmailAddressFailure.foo() = EmailAddressFailureFoo;
  // TODO: add more failures here
}
```

More information about testing a [Domain Package](/architecture/app-module#domain-package) can be found [here](/architecture/testing#testing-domain-package).

## Infrastructure Package

<BoldText>ðŸŽ¯ Implement its associated [Domain Package](/architecture/app-module#domain-package).</BoldText>

A infrastructure package implements the interface defined in its associated [Domain Package](/architecture/app-module#domain-package). This is done interacting with external or local data sources and services, such as databases or APIs, to fetch or store data as needed. Every infrastructure package can provide multiple [Service Implementations](/architecture/app-module#service-implementation) per [Service Interface](/architecture/app-module#service-interface) which can be easily injected depending on environment.

### Data Transfer Object

```dart
// user_dto.dart
@freezed
class UserDto with _$UserDto {
  const factory UserDto({
    required String id,
    // TODO: add more fields here
  }) = _UserDto;

  factory UserDto.fromDomain(User domain) {
    return UserDto(
      id: domain.id,
    );
  }

  factory UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  const UserDto._();

  User toDomain() {
    return User(
      id: id,
    );
  }
}
```

### Service Implementation

```dart
// fake_authentication_service.dart
@dev
@LazySingleton(as: IAuthenticationService)
class FakeAuthenticationService implements IAuthenticationService {
  @override
  MyMethodResult myMethod() {
    // TODO: implement
    throw UnimplementedError();
  }
}
```

More information about testing an [Infrastructure Package](/architecture/app-module#infrastructure-package) can be found [here](/architecture/testing#testing-infrastructure-package).
